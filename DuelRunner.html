<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dueling Runner</title>
  <style>
    :root {
      --bg: #0e0f13; --ink: #f2f5f9; --muted:#a7b0c0; --primary:#66e0a3;
      --danger:#ff6b6b; --amber:#ffca3a; --sky:#6ecbff; --violet:#b29cff;
      --plasma-hi:#7df0ff; --plasma-mid:#a0ff7d; --plasma-low:#ff7df0;
    }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    #wrap { position:relative; display:grid; place-items:center; height:100%; padding:16px; }
    canvas { background: linear-gradient(180deg,#11131a 0%,#0e0f13 60%); border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.5); image-rendering:pixelated; }
    #hud { position:absolute; inset:0; pointer-events:none; display:grid; place-items:start center; padding:8px; }
    #hud .row { width:min(960px,95vw); display:flex; flex-wrap:wrap; justify-content:space-between; gap:12px; align-items:center; }
    .pill { background:rgba(255,255,255,.06); backdrop-filter:blur(4px); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:6px 12px; font-size:14px; color:var(--muted); }

    #menu, #gameover { position:absolute; inset:0; display:grid; place-items:center; background: radial-gradient(50% 50% at 50% 50%, rgba(0,0,0,.55), rgba(0,0,0,.65)); }
    #menu[hidden], #gameover[hidden] { display:none; }
    .panel { width:min(640px,92vw); border-radius:16px; padding:24px; background:rgba(17,19,26,.88); border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 40px rgba(0,0,0,.6); }
    h1{ margin:0 0 6px; font-size:clamp(24px,3vw,36px); letter-spacing:.4px; }
    p{ margin:8px 0; color:var(--muted); }
    .btn{ display:inline-block; margin-top:12px; padding:10px 16px; border-radius:12px; background:var(--primary); color:#0b0e12; font-weight:800; text-transform:uppercase; letter-spacing:.6px; cursor:pointer; user-select:none; }
    .btn:active{ transform:translateY(1px); }
    .kbd{ border:1px solid rgba(255,255,255,.2); padding:2px 8px; border-radius:6px; font-weight:600; font-size:12px; color:var(--ink); background:rgba(255,255,255,.06); }

    /* Touch controls */
    #touch{ position:absolute; inset:0; display:flex; align-items:flex-end; justify-content:space-between; padding:12px; gap:12px; pointer-events:none; }
    #touch .cluster{ display:flex; gap:8px; pointer-events:auto; }
    .tbtn{ min-width:54px; min-height:54px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.08); color:var(--ink); font-weight:700; display:grid; place-items:center; user-select:none; touch-action:manipulation; }

    /* Settings pill */
    #settings { pointer-events:auto; display:flex; align-items:center; gap:10px; }
    #settings input[type="range"]{ width:120px; }

    /* Banners */
    #banner { position:absolute; top:18%; left:50%; transform:translateX(-50%); background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:10px 16px; border-radius:12px; font-weight:800; letter-spacing:.5px; display:none; }
    #banner.show{ display:block; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="Dueling Runner"></canvas>

    <div id="hud" aria-hidden="true">
      <div class="row">
        <div class="pill" id="scorePill">Score: 0</div>
        <div class="pill" id="statePill">Menu</div>
        <div class="pill" id="heartsPill">‚ù§Ô∏é‚ù§Ô∏é‚ù§Ô∏é</div>
        <div class="pill" id="djPill">Double: Ready</div>
        <div class="pill" id="settings">
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="muteToggle"> Mute
          </label>
          <input type="range" id="vol" min="0" max="100" value="22" title="Volume">
        </div>
      </div>
    </div>

    <div id="menu" role="dialog" aria-modal="true">
      <div class="panel">
        <h1>‚öîÔ∏è Dueling Runner</h1>
        <p>Run, jump & duck obstacles. When a foe appears, time your <em>duel</em>:
          dodge high/mid/low attacks and counter with your sword. Flying foes need high hits; shielded foes shift a <em>plasma shield</em> (high/mid/low) ‚Äî strike around it.</p>
        <p><strong>Controls</strong> ‚Äî ‚Üê/‚Üí move, ‚Üë or Space jump (‚Üë again = double jump), hold ‚Üì fast-fall.<br/>
        J/K/L = high/mid/low attack. <strong>Downstab</strong>: hold ‚Üì in the air and press J, K, or L ‚Äî crushes crates & instantly defeats mobs.</p>
        <div class="btn" id="startBtn">Start</div>
      </div>
    </div>

    <div id="gameover" hidden role="dialog" aria-modal="true">
      <div class="panel">
        <h1>Game Over</h1>
        <p id="finalScore">Score: 0</p>
        <div class="btn" id="retryBtn">Retry</div>
      </div>
    </div>

    <div id="banner">Wave 1</div>

    <!-- On-screen touch buttons -->
    <div id="touch" aria-hidden="false">
      <div class="cluster">
        <div class="tbtn" data-act="left">‚Üê</div>
        <div class="tbtn" data-act="right">‚Üí</div>
        <div class="tbtn" data-act="down">‚ñÅ</div>
      </div>
      <div class="cluster">
        <div class="tbtn" data-act="jump">‚§¥</div>
        <div class="tbtn" data-act="atkH">H</div>
        <div class="tbtn" data-act="atkM">M</div>
        <div class="tbtn" data-act="atkL">L</div>
      </div>
    </div>
  </div>

  <script>
  // === Dueling Runner ‚Äî Single file (with Downstab + VFX) ===
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // WebAudio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  const masterGain = audioCtx.createGain(); masterGain.gain.value = 0.22; masterGain.connect(audioCtx.destination);
  function beep({freq=440,dur=0.08,type='square',vol=0.6}){
    try{
      const t0 = audioCtx.currentTime + 0.01;
      const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
      osc.type = type; osc.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(vol, t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.connect(g); g.connect(masterGain); osc.start(t0); osc.stop(t0+dur+0.02);
    }catch(e){}
  }
  const SFX = {
    jump: ()=> beep({freq:520,dur:0.12,type:'triangle'}),
    djump: ()=> beep({freq:680,dur:0.1,type:'triangle'}),
    attack: ()=>{ beep({freq:320,dur:0.05}); beep({freq:540,dur:0.05}); },
    hit: ()=> beep({freq:180,dur:0.12,type:'sawtooth'}),
    crush: ()=> beep({freq:220,dur:0.16,type:'square'}),
    hurt: ()=> beep({freq:120,dur:0.18,type:'sine'}),
    duel: ()=> beep({freq:260,dur:0.25,type:'square'}),
    parry: ()=> beep({freq:720,dur:0.12,type:'square'}),
    over: ()=> beep({freq:90,dur:0.5,type:'sine'})
  };
  canvas.addEventListener('pointerdown', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); });

  // Settings UI
  const muteToggle = document.getElementById('muteToggle');
  const vol = document.getElementById('vol');
  muteToggle.addEventListener('change', ()=>{ masterGain.gain.value = muteToggle.checked? 0 : (vol.value/100); });
  vol.addEventListener('input', ()=>{ if(!muteToggle.checked) masterGain.gain.value = vol.value/100; });

  // Game state
  const State = { MENU:'menu', RUN:'run', DUEL:'duel', GAMEOVER:'over' };
  let state = State.MENU;
  const hud = {
    score: document.getElementById('scorePill'),
    hearts: document.getElementById('heartsPill'),
    mode: document.getElementById('statePill'),
    dj: document.getElementById('djPill'),
    menu: document.getElementById('menu'), over: document.getElementById('gameover'), final: document.getElementById('finalScore'),
  };
  const banner = document.getElementById('banner');

  const keys = new Set(); const justPressed = new Set();
  const rnd = (a,b)=> Math.random()*(b-a)+a; const clamp=(v,a,b)=> Math.max(a, Math.min(b,v));

  // Player
  const playerBase = {
    x:120, y:H-120, w:36, h:54, vx:0, vy:0, speed:4.2, onGround:false, ducking:false, hearts:3, invuln:0, attackTimer:0, attackType:null, parryFlash:0,
    kbx:0,
    usedDouble:false, doubleCD:0, fastFalling:false,
    downstab:false
  };
  let player = { ...playerBase };

  // VFX
  const particles = [];
  function spawnCrushVFX(x,y, color='#c9d2ff'){
    for(let i=0;i<12;i++){
      particles.push({
        x: x + rnd(-6,6),
        y: y + rnd(-4,4),
        vx: rnd(-2.2,2.2),
        vy: rnd(-4.0,-1.4),
        life: 420 + Math.random()*260,
        size: rnd(2,4),
        color
      });
    }
  }

  // Screen-edge flash when double jump recharges
  let djFlash=0; // ms remaining

  // World
  let scrollX=0, groundY=H-80, score=0, spawnTimer=0, obstacleTimer=0, difficultyTime=0, wave=1, nextWaveAt=500;
  const obstacles=[]; const mobs=[];

  // Duel
  let duel=null;
  const ZONES=['low','mid','high'];

  function showBanner(text){ banner.textContent=text; banner.classList.add('show'); setTimeout(()=>banner.classList.remove('show'), 1100); }

  function resetGame(){
    state = State.RUN;
    hud.menu.hidden = true; hud.over.hidden = true;
    player = { ...playerBase, y: groundY-54 };
    scrollX=0; score=0; spawnTimer=0; obstacleTimer=0; difficultyTime=0; wave=1; nextWaveAt=500;
    obstacles.length=0; mobs.length=0; duel=null; justPressed.clear(); keys.clear();
    hud.mode.textContent='Running';
    showBanner('Go!');
  }

  // Inputs
  addEventListener('keydown', e=>{ keys.add(e.key); justPressed.add(e.key); if(e.key===' '||e.key==='ArrowUp') e.preventDefault(); });
  addEventListener('keyup', e=>{ keys.delete(e.key); });
  document.getElementById('startBtn').onclick=()=> resetGame();
  document.getElementById('retryBtn').onclick=()=> resetGame();

  // Spawning
  function spawnObstacle(){
    const gap=rnd(200,360);
    const w=rnd(28,64), h=rnd(22,42);
    const x=W+gap;
    obstacles.push({x, y:groundY-h, w, h, type:'crate'});
  }
  function spawnMob(){
    const kinds=['regular','flying','shielded'];
    const weapons=['sword','spear','bow','punch'];
    const kind=kinds[Math.floor(Math.random()*kinds.length)];
    const weapon=weapons[Math.floor(Math.random()*weapons.length)];
    const base = {
      x:W+60,
      y:kind==='flying'? groundY-170 : groundY-72,
      w:kind==='flying'? 64 : 56,
      h:kind==='flying'? 48 : 72,
      kind, weapon, speed:3.9, kbx:0,
      maxhp: (kind==='shielded'? 3 : 2)
    };
    base.hp = base.maxhp;
    mobs.push(base);
  }

  // Helpers
  function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

  // ATTACKS
  function tryPlayerAttack(which){
    // Downstab: if airborne & holding down, any attack triggers downstab
    if(!player.onGround && keys.has('ArrowDown')){
      player.attackType='down'; player.attackTimer=280; player.downstab=true; SFX.crush();
      return;
    }

    if(player.attackTimer>0) return;
    player.attackType=which; player.attackTimer=200; player.downstab=false; SFX.attack();

    // RUN: break obstacles with LOW attack straight ahead
    if(state===State.RUN && which==='low'){
      const reach=58;
      const attackBox={ x:player.x+player.w, y:player.y+player.h-20, w:reach, h:18 };
      for(let i=obstacles.length-1;i>=0;i--){
        const o=obstacles[i];
        if(aabb(attackBox,o)){
          obstacles.splice(i,1);
          score += 20;
          spawnCrushVFX(o.x+o.w/2, o.y, '#a3b0c9');
          SFX.crush();
        }
      }
    }

    // DUEL damage/parry
    if(state===State.DUEL && duel){
      const reach=60;
      const hitbox={
        x:player.x+player.w,
        y:player.y + (which==='high'?0:(which==='mid'?player.h*0.40:player.h*0.72)) - 10,
        w:reach, h:20
      };
      let blocked=false;
      if(duel.foe.kind==='shielded' && duel.shieldPos===which) blocked=true;
      if(duel.foe.kind==='flying' && which!=='high') blocked=true;

      // Parry
      if(duel.activeStrike && duel.parryWindow>0){
        const zone = zoneFromY(duel.activeStrike.y);
        if(zone===which){
          duel.activeStrike=null; duel.parryWindow=0;
          duel.foeHP=Math.max(0,duel.foeHP-1);
          SFX.parry(); player.parryFlash=220; score+=75;
          if(duel.foeHP<=0) endDuel(true);
          return;
        }
      }

      const foeBox = foeAABB();
      if(!blocked && aabb(hitbox, foeBox)){ duel.foeHP-=1; duel.hitFlash=160; if(duel.foeHP<=0) endDuel(true); }
    }
  }

  // Jumps
  function doGroundJump(){ player.vy=-10.5; player.onGround=false; SFX.jump(); }
  function doDoubleJump(){
    player.vy = -10.2;
    player.usedDouble = true;
    player.doubleCD = 3000;
    SFX.djump();
  }

  function applyPlayerPhysics(){
    const left = keys.has('ArrowLeft')||keys.has('a'); const right = keys.has('ArrowRight')||keys.has('d'); const move=(right?1:0)-(left?1:0);
    player.vx = move*player.speed;

    if(state===State.DUEL){
      player.x = clamp(player.x + player.vx, duel.arenaX-70, duel.arenaX+70);
    } else {
      player.x = clamp(player.x + player.vx, 40, W*0.45);
    }

    const wantJump = justPressed.has(' ')||justPressed.has('ArrowUp');
    player.ducking = keys.has('ArrowDown');
    player.fastFalling = !player.onGround && keys.has('ArrowDown');

    if(wantJump){
      if(player.onGround){
        doGroundJump();
      } else if(!player.onGround && !player.usedDouble && player.doubleCD<=0){
        doDoubleJump();
      }
    }

    // Gravity (faster if fast-falling)
    const g = player.fastFalling ? 0.85 : 0.45;
    player.vy += g;
    player.y += player.vy;

    // Knockback decay
    if(Math.abs(player.kbx) > 0.01){ player.x += player.kbx; player.kbx *= 0.88; }

    const standH=54, duckH=34; player.h = (player.ducking && state!==State.DUEL)? duckH : standH;

    const wasAir = !player.onGround;
    if(player.y+player.h>=groundY){ player.y=groundY-player.h; if(wasAir){ player.vy=0; } player.onGround=true; player.downstab=false; }
    else { player.onGround=false; }

    // Timers
    const prevCD = player.doubleCD;
    if(player.attackTimer>0) player.attackTimer-=16.67;
    if(player.invuln>0) player.invuln-=16.67;
    if(player.parryFlash>0) player.parryFlash-=16.67;
    if(player.doubleCD>0) player.doubleCD-=16.67;
    if(prevCD>0 && player.doubleCD<=0){ djFlash=420; } // flash when recharged
    if(player.onGround && player.doubleCD<=0) player.usedDouble=false; // can recharge only after cooldown

    // Update particles
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.22; p.life -= 16.67;
      if(p.life<=0) particles.splice(i,1);
    }
    if(djFlash>0) djFlash-=16.67;
  }

  // Downstab crush logic: landing on obstacle while falling & downstab active
  function maybeDownstabCrush(o){
    if(!player.downstab) return false;
    const fallingDown = player.vy>0;
    const nearTop = Math.abs((player.y+player.h) - o.y) < 14;
    const horizontalOverlap = (player.x + player.w > o.x + 6) && (player.x < o.x + o.w - 6);
    if(fallingDown && nearTop && horizontalOverlap){
      SFX.crush();
      player.vy = -11.5; // bounce
      score += 40;
      spawnCrushVFX(o.x+o.w/2, o.y, '#a3b0c9');
      return true;
    }
    return false;
  }

  function damagePlayer(){
    if(player.invuln>0) return;
    player.hearts-=1;
    player.invuln=900;
    SFX.hurt();
    if(player.hearts<=0){
      state=State.GAMEOVER; hud.over.hidden=false; hud.final.textContent=`Score: ${Math.floor(score)}`; SFX.over();
    }
  }

  // Player vs obstacle during RUN
  function collidePlayerWithObstacle(o, idx){
    if(state!==State.RUN) return false;

    // Try downstab crush first (new)
    if(maybeDownstabCrush(o)){
      obstacles.splice(idx,1);
      return true;
    }

    if(player.invuln<=0){ damagePlayer(); }
    player.kbx = -5.5;
    player.vy = Math.min(player.vy, -6);
    if(player.x + player.w > o.x && player.x < o.x) player.x = o.x - player.w - 1;
    SFX.hit();
    return false;
  }

  // Mob/obstacle collision knockback (bounce)
  function collideMobWithObstacle(m,o){
    if(m.kind==='flying') return;
    if(m.x + m.w > o.x && m.x < o.x){
      m.x = o.x - m.w - 1; m.kbx = 5.5;
    } else if(m.x < o.x + o.w && m.x > o.x){
      m.x = o.x + o.w + 1; m.kbx = -5.0;
    }
  }

  function updateRun(dt){
    difficultyTime+=dt; const diff=Math.min(3.2, 1 + difficultyTime/20000);
    const runSpeed=5.2*diff;
    scrollX+=runSpeed; score+=dt*0.06*diff;
    if(score>=nextWaveAt){ showBanner(`Wave ${++wave}`); nextWaveAt+=500+150*wave; }

    obstacleTimer-=dt;
    if(obstacleTimer<=0){
      const base=1300/diff;
      obstacleTimer=base + Math.random()*(1100/diff);
      spawnObstacle();
    }

    spawnTimer-=dt;
    if(spawnTimer<=0){
      const base=2000/diff;
      spawnTimer=base + Math.random()*(1600/diff);
      spawnMob();
    }

    // Move world
    obstacles.forEach(o=> o.x -= runSpeed);
    for(let i=obstacles.length-1;i>=0;i--){ if(obstacles[i].x+obstacles[i].w<-20) obstacles.splice(i,1); }

    mobs.forEach(m=>{
      m.x -= m.speed*diff*0.9;
      if(Math.abs(m.kbx)>0.01){ m.x += m.kbx; m.kbx *= 0.88; }
    });
    for(let i=mobs.length-1;i>=0;i--){ if(mobs[i].x+mobs[i].w<-20) mobs.splice(i,1); }

    // Collisions: player vs obstacles (allow attack-break + downstab)
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];

      // low attack side-break (kept)
      if(player.attackType==='low' && player.attackTimer>0){
        const sideHit={ x:player.x+player.w-2, y:o.y-6, w:60, h:o.h+12 };
        if(aabb(sideHit,o)){
          obstacles.splice(i,1);
          score+=20; spawnCrushVFX(o.x+o.w/2, o.y, '#a3b0c9'); SFX.crush();
          continue;
        }
      }

      if(aabb({x:player.x,y:player.y,w:player.w,h:player.h}, o)){
        if(collidePlayerWithObstacle(o, i)){
          // crushed and removed already
        }
      }
    }

    // Collisions: mobs vs obstacles
    for(const m of mobs){
      for(const o of obstacles){
        if(aabb({x:m.x,y:m.y,w:m.w,h:m.h}, o)){
          collideMobWithObstacle(m,o);
        }
      }
    }

    // Player vs mobs: check Downstab instant-kill BEFORE duel trigger
    for(let i=0;i<mobs.length;i++){
      const m=mobs[i];
      const pb={x:player.x,y:player.y,w:player.w,h:player.h};
      if(aabb(pb,m)){
        if(player.downstab && player.vy>0){ // falling downstab
          // pop the mob with VFX & bounce
          spawnCrushVFX(m.x + m.w/2, m.y, '#ff86a6');
          SFX.crush();
          player.vy = -12.0; // stronger bounce for mobs
          score += 120;
          mobs.splice(i,1);
          break;
        } else {
          // regular contact ‚Üí duel
          const foe={...m};
          mobs.splice(i,1);
          beginDuel(foe);
          break;
        }
      }
    }
  }

  // ==== DUEL ================================================================
  function foeAABB(){
    if(!duel) return {x:0,y:0,w:0,h:0};
    const f=duel.foe;
    return {
      x:duel.arenaX+60,
      y:f.kind==='flying'? groundY-170 : groundY-72,
      w:f.kind==='flying'? 64 : 56,
      h:f.kind==='flying'? 48 : 72
    };
  }
  function nextZone(){ return ZONES[Math.floor(Math.random()*ZONES.length)]; }
  function zoneFromY(y){ return y < groundY-150 ? 'high' : (y < groundY-100 ? 'mid' : 'low'); }

  function beginDuel(foe){
    state=State.DUEL; hud.mode.textContent='Duel'; SFX.duel();
    const maxhp = foe.maxhp ?? (foe.kind==='shielded'?3:(foe.kind==='flying'?2:2));
    const hp = foe.hp ?? maxhp;
    duel={
      foe,
      arenaX: player.x+40,
      timer:0,
      foeHP: hp,
      foeMaxHP: maxhp,
      nextAttackAt:900,
      pattern:nextZone(),
      shieldPos:'mid',
      shieldTimer:0,
      projectiles:[],
      hitFlash:0,
      activeStrike:null,
      parryWindow:0
    };
  }

  function endDuel(playerWon){
    state=State.RUN;
    hud.mode.textContent='Running';
    duel=null;
    if(playerWon) score+=150; else score=Math.max(0,score-100);
  }

  function updateDuel(dt){
    duel.timer+=dt;

    if(duel.foe.kind==='shielded'){
      duel.shieldTimer+=dt;
      if(duel.shieldTimer>650){
        duel.shieldTimer=0;
        const choices=ZONES.filter(z=>z!==duel.shieldPos);
        duel.shieldPos=choices[Math.floor(Math.random()*choices.length)];
      }
    }

    if(duel.foe.weapon==='bow'){
      if(!duel.nextArrowAt) duel.nextArrowAt=1200;
      duel.nextArrowAt-=dt;
      if(duel.nextArrowAt<=0){
        duel.nextArrowAt=1300+Math.random()*700;
        const zone=nextZone();
        const p={x:duel.arenaX+60, y:groundY-(zone==='high'?200: zone==='mid'?128:92), w:18, h:8, vx:-6.4, zone};
        duel.projectiles.push(p);
      }
    }

    duel.nextAttackAt-=dt;
    if(duel.nextAttackAt<=0){
      const zone=duel.pattern;
      const s={ x:duel.arenaX+36, y:groundY-(zone==='high'?200: zone==='mid'?128:92), w:110, h:30, active:220 };
      duel.activeStrike=s; duel.parryWindow=220;
      duel.pattern=nextZone();
      const base=duel.foe.weapon==='spear'?1050:(duel.foe.weapon==='punch'?780:960);
      duel.nextAttackAt=base+Math.random()*520;
    }
    if(duel.parryWindow>0) duel.parryWindow-=dt;
    if(duel.activeStrike){ duel.activeStrike.active-=dt; if(duel.activeStrike.active<=0) duel.activeStrike=null; }

    for(let i=duel.projectiles.length-1;i>=0;i--){
      const p=duel.projectiles[i];
      p.x+=p.vx;
      const pb={x:p.x,y:p.y,w:p.w,h:p.h};
      if(aabb(pb,{x:player.x,y:player.y,w:player.w,h:player.h})){
        damagePlayer();
        duel.projectiles.splice(i,1);
      } else if(p.x<player.x-140) {
        duel.projectiles.splice(i,1);
      }
    }

    if(duel.activeStrike){
      const s=duel.activeStrike;
      const pb={x:player.x,y:player.y,w:player.w,h:player.h};
      if(aabb(pb,s)){
        const zone=zoneFromY(s.y);
        const dodged=(zone==='high' && player.y+player.h < groundY-120) ||
                     (zone==='low' && (keys.has('ArrowDown')||player.h<40)) ||
                     (zone==='mid' && (player.y+player.h<groundY-90 || keys.has('ArrowDown')));
        if(!dodged) damagePlayer();
      }
    }
  }

  // ==== RENDERING ===========================================================
  function drawGround(){
    ctx.fillStyle='#0b0c10'; ctx.fillRect(0,groundY,W,H-groundY);
    ctx.strokeStyle='rgba(255,255,255,.06)';
    ctx.beginPath();
    for(let x=-((scrollX*0.5)%40); x<W; x+=40){ ctx.moveTo(x,groundY+2); ctx.lineTo(x+20,groundY+2); }
    ctx.stroke();
  }
  function drawParallax(){
    ctx.fillStyle='rgba(255,255,255,.06)';
    const baseY=groundY-120;
    for(let i=0;i<12;i++){
      const w=60+(i%3)*20;
      const x=(i*180 - (scrollX*0.2)%180);
      ctx.fillRect(x, baseY-(i%4)*20, w, 100+(i%3)*22);
    }
  }

  function drawPixelGrid(grid, palette, x, y, scale=2){
    for(let r=0;r<grid.length;r++){
      const row = grid[r];
      for(let c=0;c<row.length;c++){
        const ch=row[c];
        if(ch==='.' ) continue;
        ctx.fillStyle = palette[ch] || '#fff';
        ctx.fillRect(Math.floor(x+c*scale), Math.floor(y+r*scale), scale, scale);
      }
    }
  }

  const palKnight = { k:'#89a2ff', s:'#dfe6ff', b:'#2b2f3a', f:'#f7e4b2', h:'#454a5c', g:'#66e0a3' };
  const knightGrid = [
    "......g...........",
    "......g...........",
    "......g...........",
    "....kkkkk.........",
    "...kkfffkk........",
    "...kkfffkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkskskk........",
    "...kkbbbkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkskskk........",
    "...kkskskk........",
    "...kkhhhkk........",
    "...kkhhhkk........",
    "...kkhhhkk........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........"
  ];

  const palGob = { G:'#76e06e', D:'#3a7a35', E:'#ffffff', e:'#111111', B:'#2b2f3a', M:'#9b6b3b' };
  const goblinGround = [
    "..BBBBBBBBBBBBBBBB..",
    ".BGGGGGGGGGGGGGGGB.",
    "BGGGGEeEGGGGGGEeGGB",
    "BGGGGGGGGGGGGGGGGGB",
    "BGGGMGGGGMGGGGMGGGB",
    "BGGGGGGGGGGGGGGGGGB",
    "BGGGGGGGGGGGGGGGGGB",
    ".BGGGGBBGGGGBBGGGB.",
    "..BGB......BGB.. ..",
    "..BGB......BGB.....",
    "...B........B......"
  ];
  const goblinFlying = [
    "....BBBBBBBBBB....",
    "..BGGGGGGGGGGGB..W",
    ".BGGGEeEGGGGEGGB.W",
    "BGGGGGGGGGGGGGGGBW",
    ".BGGGGGGGGGGGGGGBW",
    "..BGGGGGGGGGGGGB.W",
    ".WBGGGGGGGGGGGBW..",
    "W..BGGGGGGGGGB..W.",
    ".W..BBBBBBBB..W...",
    "..W.........W....."
  ];
  const palWing = { W:'#b29cff' };

  function drawKnight(x,y,w,h,attackType,attackTimer,ducking,parryFlash){
    const gw = knightGrid[0].length, gh = knightGrid.length;
    const scale = Math.floor(Math.min(w/gw, h/gh));
    const sx = x + Math.floor((w - gw*scale)/2);
    const sy = y + Math.floor(h - gh*scale);

    drawPixelGrid(knightGrid, palKnight, sx, sy, scale);

    if(parryFlash>0){
      const a = Math.min(0.35, parryFlash/220*0.35);
      ctx.fillStyle = `rgba(255,255,210,${a})`;
      ctx.fillRect(x-2, y-2, w+4, h+4);
    }

    // Sword pose
    if(attackType==='down'){
      // straight down blade
      const t = attackTimer>0 ? 1 - attackTimer/280 : 0;
      const reach = 14 + Math.floor(28*t);
      const bladeW = 4;
      ctx.fillStyle = '#cfd8ff';
      ctx.fillRect(x + w/2 - 2, y + h - 4, 4, 4);
      ctx.fillStyle = '#e6ecff';
      ctx.fillRect(x + w/2 - bladeW/2, y + h - 2, bladeW, reach);
    } else {
      // forward slashes
      const handYHigh = y + 6;
      const handYMid  = y + h*0.45;
      const handYLow  = y + h*0.75;
      const zoneY = attackType==='high' ? handYHigh : attackType==='mid' ? handYMid : handYLow;
      const t = attackTimer>0 ? 1 - attackTimer/200 : 0;
      const reach = 18 + Math.floor(22*t);
      const bladeW = Math.max(2, Math.floor(scale*1.0));
      ctx.fillStyle = '#cfd8ff';
      ctx.fillRect(x + w - 6, zoneY - 2, 4, 4);
      ctx.fillStyle = '#e6ecff';
      ctx.fillRect(x + w - 2, zoneY - Math.floor(bladeW/2), reach, bladeW);
    }
  }

  function drawGoblin(m){
    const scale = 3; // bigger mobs
    if(m.kind==='flying'){
      drawPixelGrid(goblinFlying, {...palGob, ...palWing}, m.x, (groundY-170), scale);
    }else{
      drawPixelGrid(goblinGround, palGob, m.x, (groundY-72), scale);
    }
    ctx.fillStyle='#111';
    ctx.font='14px system-ui';
    const glyphs={sword:'‚öî',spear:'üó°',bow:'üèπ',punch:'‚úä'};
    const y = m.kind==='flying'? (groundY-170) : (groundY-72);
    ctx.fillText(glyphs[m.weapon]||'?', m.x+8, y+16);

    // visible hitbox ring
    ctx.strokeStyle='rgba(255,255,255,0.18)';
    const r = (m.kind==='flying'? 26 : 32);
    ctx.beginPath();
    ctx.arc(m.x + (m.w/2), y + (m.h/2), r, 0, Math.PI*2);
    ctx.stroke();
  }

  function drawObstacles(){
    ctx.fillStyle='#2b2f3a';
    obstacles.forEach(o=>{
      ctx.fillRect(o.x,o.y,o.w,o.h);
      ctx.strokeStyle='rgba(255,255,255,.08)';
      ctx.strokeRect(o.x,o.y,o.w,o.h);
    });
  }

  // Plasma shield (lane-colored, glow)
  function drawPlasmaShield(box, lane){
    const laneColor = lane==='high' ? getComputedStyle(document.documentElement).getPropertyValue('--plasma-hi').trim()
                      : lane==='mid' ? getComputedStyle(document.documentElement).getPropertyValue('--plasma-mid').trim()
                      : getComputedStyle(document.documentElement).getPropertyValue('--plasma-low').trim();
    const map={high: box.y-16, mid: box.y+8, low: box.y+34};
    const y = map[lane];
    ctx.save();
    ctx.fillStyle=laneColor;
    ctx.shadowColor=laneColor; ctx.shadowBlur=14;
    ctx.globalAlpha=0.85;
    ctx.fillRect(box.x-14, y, 12, 14);
    ctx.restore();

    ctx.strokeStyle='rgba(255,255,255,0.25)';
    ctx.strokeRect(box.x-14, y, 12, 14);
  }

  function drawTelegraphSlab(s){
    ctx.save();
    ctx.fillStyle='rgba(255,64,64,0.55)';
    ctx.shadowColor='rgba(255,64,64,0.8)'; ctx.shadowBlur=12;
    ctx.fillRect(s.x, s.y, s.w, s.h);
    ctx.restore();
  }

  function drawHPBar(x, y, w, h, pct){
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(x, y, Math.max(0, Math.min(1, pct))*w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
  }

  function drawMob(m){
    ctx.save();
    const wob = m.kind==='flying'? Math.sin((scrollX+m.x)*0.05)*4 : 0;
    ctx.translate(0, wob);
    drawGoblin(m);

    const y = m.kind==='flying'? (groundY-170) : (groundY-72);
    const barW = 48, barH = 6;
    const pct = (m.hp ?? m.maxhp) / (m.maxhp || 1);
    drawHPBar(m.x + (m.w - barW)/2, y - 12, barW, barH, pct);

    ctx.restore();
  }

  function drawDuel(){
    const foe=duel.foe;
    const box=foeAABB();
    ctx.strokeStyle='rgba(255,255,255,.15)';
    ctx.strokeRect(duel.arenaX-80, groundY-120, 210, 140);

    ctx.save();
    const m = { ...foe, x: box.x, w: box.w, h: box.h };
    drawGoblin(m);
    ctx.restore();

    const barW = 78, barH = 6;
    const barX = box.x + (box.w - barW)/2;
    const barY = box.y - 16;
    const pct = (duel.foeHP || 0) / (duel.foeMaxHP || 1);
    drawHPBar(barX, barY, barW, barH, pct);

    if(foe.kind==='shielded'){ drawPlasmaShield(box, duel.shieldPos); }

    const zone=duel.pattern;
    const zy= zone==='high'? box.y-40 : zone==='mid'? box.y-12 : box.y+16;
    ctx.save(); ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(box.x-10, zy, 6, 28); ctx.restore();

    if(duel.activeStrike){ drawTelegraphSlab(duel.activeStrike); }

    ctx.fillStyle='#ffca3a';
    duel.projectiles.forEach(p=> ctx.fillRect(p.x,p.y,p.w,p.h));

    if(duel.hitFlash>0){
      duel.hitFlash-=16.67;
      ctx.fillStyle='rgba(255,255,255,.1)';
      ctx.fillRect(box.x-4, box.y-4, box.w+8, box.h+8);
    }
  }

  function drawParticles(){
    for(const p of particles){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life/450));
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  function drawUI(){
    hud.score.textContent=`Score: ${Math.floor(score)}`;
    hud.hearts.textContent='‚ù§Ô∏é'.repeat(Math.max(0,player.hearts));
    hud.mode.textContent = state===State.DUEL? 'Duel' : state===State.RUN? 'Running' : state===State.MENU? 'Menu' : 'Game Over';

    // Double jump HUD
    if(player.doubleCD>0){
      const secs = Math.max(0, player.doubleCD/1000);
      hud.dj.textContent = `Double: ${secs.toFixed(1)}s`;
      hud.dj.style.color = 'var(--amber)';
    }else{
      hud.dj.textContent = 'Double: Ready';
      hud.dj.style.color = 'var(--muted)';
    }
  }

  function drawPlayer(){
    ctx.save();
    ctx.globalAlpha = player.invuln>0? 0.7:1;
    drawKnight(player.x, player.y, player.w, player.h, player.attackType||'mid', player.attackTimer, player.ducking, player.parryFlash);

    // On-player double-jump ring when ready (subtle)
    if(player.doubleCD<=0 && !player.onGround){
      ctx.strokeStyle='rgba(180,240,255,0.35)';
      ctx.beginPath(); ctx.arc(player.x+player.w/2, player.y+player.h, 14, 0, Math.PI*2); ctx.stroke();
    }

    // Screen-edge flash when DJ recharges
    if(djFlash>0){
      const a = Math.min(0.35, djFlash/420*0.35);
      ctx.strokeStyle = `rgba(160,220,255,${a})`;
      ctx.lineWidth = 6;
      ctx.strokeRect(4,4,W-8,H-8);
    }

    ctx.restore();
  }

  function drawHearts(){
    // kept from previous version ‚Äì cute hearts in-canvas
    const MAX = 3, size = 16, gap = 8, startX = 18, startY = 18;
    for(let i=0;i<MAX;i++){
      const cx = startX + i*(size + gap) + size/2;
      const cy = startY + size/2;
      const filled = i < player.hearts;
      const r = size/4;
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx - r, cy - r, r, 0, Math.PI, true);
      ctx.arc(cx + r, cy - r, r, 0, Math.PI, true);
      ctx.lineTo(cx, cy + size*0.6);
      ctx.closePath();
      ctx.fillStyle = filled ? '#ff6b6b' : 'rgba(255,255,255,0.15)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = Math.max(1, size*0.1); ctx.stroke();
      ctx.restore();
    }
  }

  // Loop
  let last=0;
  function frame(t){
    const dt=Math.min(32, t-last || 16.67);
    last=t;
    ctx.clearRect(0,0,W,H);
    drawParallax();
    if(state===State.RUN){ updateRun(dt); }
    applyPlayerPhysics();
    drawGround();
    if(state===State.RUN){ drawObstacles(); mobs.forEach(drawMob);}
    if(state===State.DUEL){ updateDuel(dt); drawDuel(); }
    drawParticles();
    drawPlayer();
    drawHearts();
    drawUI();
    justPressed.clear();
    requestAnimationFrame(frame);
  }

  // Attack keys
  addEventListener('keydown', e=>{
    if(state===State.MENU && (e.key==='Enter'||e.key===' ')) resetGame();
    if(state===State.GAMEOVER && (e.key==='Enter'||e.key===' ')) resetGame();
    if(e.key==='j'||e.key==='J') tryPlayerAttack('high');
    if(e.key==='k'||e.key==='K') tryPlayerAttack('mid');
    if(e.key==='l'||e.key==='L') tryPlayerAttack('low');
  });

  // Touch buttons ‚Üí keys
  (function(){
    const touch=document.getElementById('touch');
    const bindings={left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', jump:' ', atkH:'j', atkM:'k', atkL:'l'};
    function press(k){ keys.add(k); justPressed.add(k);}
    function release(k){ keys.delete(k);}
    function bind(el,key){
      ['touchstart','mousedown'].forEach(evt=> el.addEventListener(evt,e=>{ e.preventDefault(); press(key); }));
      ['touchend','touchcancel','mouseup','mouseleave'].forEach(evt=> el.addEventListener(evt,e=>{ e.preventDefault(); release(key); }));
    }
    touch.querySelectorAll('.tbtn').forEach(btn=>{
      const act=btn.getAttribute('data-act');
      const key=bindings[act];
      if(key) bind(btn,key);
    });
  })();

  // Swipe gestures
  (function(){
    let sx=0, sy=0;
    const TH=28;
    canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
    canvas.addEventListener('touchend', e=>{
      const t=e.changedTouches[0];
      const dx=t.clientX-sx, dy=t.clientY-sy;
      if(Math.abs(dx)<TH && Math.abs(dy)<TH) return;
      if(Math.abs(dy)>Math.abs(dx)){
        if(dy<-TH){ justPressed.add(' '); }
        else { keys.add('ArrowDown'); setTimeout(()=> keys.delete('ArrowDown'), 220); }
      } else {
        if(dx>TH){ keys.add('ArrowRight'); setTimeout(()=> keys.delete('ArrowRight'), 160); }
        else if(dx<-TH){ keys.add('ArrowLeft'); setTimeout(()=> keys.delete('ArrowLeft'), 160); }
      }
    }, {passive:true});
  })();

  requestAnimationFrame(frame);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dueling Runner</title>
  <style>
    :root {
      --bg: #0e0f13; --ink: #f2f5f9; --muted:#a7b0c0; --primary:#66e0a3;
      --danger:#ff6b6b; --amber:#ffca3a; --sky:#6ecbff; --violet:#b29cff;
    }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    #wrap { position:relative; display:grid; place-items:center; height:100%; padding:16px; }
    canvas { background: linear-gradient(180deg,#11131a 0%,#0e0f13 60%); border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.5); image-rendering:pixelated; }
    #hud { position:absolute; inset:0; pointer-events:none; display:grid; place-items:start center; padding:8px; }
    #hud .row { width:min(960px,95vw); display:flex; justify-content:space-between; gap:12px; align-items:center; }
    .pill { background:rgba(255,255,255,.06); backdrop-filter:blur(4px); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:6px 12px; font-size:14px; color:var(--muted); }

    #menu, #gameover { position:absolute; inset:0; display:grid; place-items:center; background: radial-gradient(50% 50% at 50% 50%, rgba(0,0,0,.55), rgba(0,0,0,.65)); }
    #menu[hidden], #gameover[hidden] { display:none; }
    .panel { width:min(640px,92vw); border-radius:16px; padding:24px; background:rgba(17,19,26,.88); border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 40px rgba(0,0,0,.6); }
    h1{ margin:0 0 6px; font-size:clamp(24px,3vw,36px); letter-spacing:.4px; }
    p{ margin:8px 0; color:var(--muted); }
    .btn{ display:inline-block; margin-top:12px; padding:10px 16px; border-radius:12px; background:var(--primary); color:#0b0e12; font-weight:800; text-transform:uppercase; letter-spacing:.6px; cursor:pointer; user-select:none; }
    .btn:active{ transform:translateY(1px); }
    .kbd{ border:1px solid rgba(255,255,255,.2); padding:2px 8px; border-radius:6px; font-weight:600; font-size:12px; color:var(--ink); background:rgba(255,255,255,.06); }

    /* Touch controls */
    #touch{ position:absolute; inset:0; display:flex; align-items:flex-end; justify-content:space-between; padding:12px; gap:12px; pointer-events:none; }
    #touch .cluster{ display:flex; gap:8px; pointer-events:auto; }
    .tbtn{ min-width:54px; min-height:54px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.08); color:var(--ink); font-weight:700; display:grid; place-items:center; user-select:none; touch-action:manipulation; }

    /* Settings pill */
    #settings { pointer-events:auto; display:flex; align-items:center; gap:10px; }
    #settings input[type="range"]{ width:120px; }

    /* Banners */
    #banner { position:absolute; top:18%; left:50%; transform:translateX(-50%); background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:10px 16px; border-radius:12px; font-weight:800; letter-spacing:.5px; display:none; }
    #banner.show{ display:block; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="Dueling Runner"></canvas>

    <div id="hud" aria-hidden="true">
      <div class="row">
        <div class="pill" id="scorePill">Score: 0</div>
        <div class="pill" id="statePill">Menu</div>
        <div class="pill" id="heartsPill">❤︎❤︎❤︎</div>
        <div class="pill" id="settings">
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="muteToggle"> Mute
          </label>
          <input type="range" id="vol" min="0" max="100" value="22" title="Volume">
        </div>
      </div>
    </div>

    <div id="menu" role="dialog" aria-modal="true">
      <div class="panel">
        <h1>⚔️ Dueling Runner</h1>
        <p>Run, jump & duck obstacles. When a foe appears, time your <em>duel</em>:
          dodge high/mid/low attacks and counter with your sword. Flying foes need high hits; shielded foes shift a shield (high/mid/low) — strike around it.</p>
        <p><strong>Controls</strong> — ←/→ move, ↑ or Space jump, hold ↓ duck, J/K/L = high/mid/low attack.<br/>
        <strong>Touch</strong> — swipe ↑ jump, ↓ duck, ←/→ move; buttons provided.</p>
        <div class="btn" id="startBtn">Start</div>
      </div>
    </div>

    <div id="gameover" hidden role="dialog" aria-modal="true">
      <div class="panel">
        <h1>Game Over</h1>
        <p id="finalScore">Score: 0</p>
        <div class="btn" id="retryBtn">Retry</div>
      </div>
    </div>

    <div id="banner">Wave 1</div>

    <!-- On-screen touch buttons -->
    <div id="touch" aria-hidden="false">
      <div class="cluster">
        <div class="tbtn" data-act="left">←</div>
        <div class="tbtn" data-act="right">→</div>
        <div class="tbtn" data-act="down">▁</div>
      </div>
      <div class="cluster">
        <div class="tbtn" data-act="jump">⤴</div>
        <div class="tbtn" data-act="atkH">H</div>
        <div class="tbtn" data-act="atkM">M</div>
        <div class="tbtn" data-act="atkL">L</div>
      </div>
    </div>
  </div>

  <script>
  // === Dueling Runner — Single file ===
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // WebAudio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  const masterGain = audioCtx.createGain(); masterGain.gain.value = 0.22; masterGain.connect(audioCtx.destination);
  function beep({freq=440,dur=0.08,type='square',vol=0.6}){
    try{
      const t0 = audioCtx.currentTime + 0.01;
      const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
      osc.type = type; osc.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(vol, t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.connect(g); g.connect(masterGain); osc.start(t0); osc.stop(t0+dur+0.02);
    }catch(e){}
  }
  const SFX = {
    jump: ()=> beep({freq:520,dur:0.12,type:'triangle'}),
    attack: ()=>{ beep({freq:320,dur:0.05}); beep({freq:540,dur:0.05}); },
    hit: ()=> beep({freq:180,dur:0.12,type:'sawtooth'}),
    hurt: ()=> beep({freq:120,dur:0.18,type:'sine'}),
    duel: ()=> beep({freq:260,dur:0.25,type:'square'}),
    parry: ()=> beep({freq:720,dur:0.12,type:'square'}),
    over: ()=> beep({freq:90,dur:0.5,type:'sine'})
  };
  canvas.addEventListener('pointerdown', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); });

  // Settings UI
  const muteToggle = document.getElementById('muteToggle');
  const vol = document.getElementById('vol');
  muteToggle.addEventListener('change', ()=>{ masterGain.gain.value = muteToggle.checked? 0 : (vol.value/100); });
  vol.addEventListener('input', ()=>{ if(!muteToggle.checked) masterGain.gain.value = vol.value/100; });

  // Game state
  const State = { MENU:'menu', RUN:'run', DUEL:'duel', GAMEOVER:'over' };
  let state = State.MENU;
  const hud = {
    score: document.getElementById('scorePill'), hearts: document.getElementById('heartsPill'), mode: document.getElementById('statePill'),
    menu: document.getElementById('menu'), over: document.getElementById('gameover'), final: document.getElementById('finalScore'),
  };
  const banner = document.getElementById('banner');

  const keys = new Set(); const justPressed = new Set();
  const rnd = (a,b)=> Math.random()*(b-a)+a; const clamp=(v,a,b)=> Math.max(a, Math.min(b,v));

  // Player
  const playerBase = { 
    x:120, y:H-120, w:36, h:54, vx:0, vy:0, speed:4.2, onGround:false, ducking:false, hearts:3, invuln:0, attackTimer:0, attackType:null, parryFlash:0,
    kbx:0 // knockback X velocity
  };
  let player = { ...playerBase };

  // World
  let scrollX=0, groundY=H-80, score=0, spawnTimer=0, obstacleTimer=0, difficultyTime=0, wave=1, nextWaveAt=500;
  const obstacles=[]; const mobs=[]; // runner-phase entities

  // Duel
  let duel=null; // {foe, arenaX, timer, foeHP, foeMaxHP, pattern, nextAttackAt, shieldPos, shieldTimer, projectiles, activeStrike, hitFlash, parryWindow}
  const ZONES=['low','mid','high'];

  function showBanner(text){ banner.textContent=text; banner.classList.add('show'); setTimeout(()=>banner.classList.remove('show'), 1100); }

  function resetGame(){
    state = State.RUN;
    hud.menu.hidden = true; hud.over.hidden = true;
    player = { ...playerBase, y: groundY-54 };
    scrollX=0; score=0; spawnTimer=0; obstacleTimer=0; difficultyTime=0; wave=1; nextWaveAt=500;
    obstacles.length=0; mobs.length=0; duel=null; justPressed.clear(); keys.clear();
    hud.mode.textContent='Running';
    showBanner('Go!');
  }

  // Inputs
  addEventListener('keydown', e=>{ keys.add(e.key); justPressed.add(e.key); if(e.key===' '||e.key==='ArrowUp') e.preventDefault(); });
  addEventListener('keyup', e=>{ keys.delete(e.key); });
  document.getElementById('startBtn').onclick=()=> resetGame();
  document.getElementById('retryBtn').onclick=()=> resetGame();

  // Spawning
  function spawnObstacle(){ 
    const gap=rnd(200,360);
    const w=rnd(24,60), h=rnd(20,40); 
    const x=W+gap; 
    obstacles.push({x, y:groundY-h, w, h, type:'crate'}); 
  }
  function spawnMob(){ 
    const kinds=['regular','flying','shielded']; 
    const weapons=['sword','spear','bow','punch']; 
    const kind=kinds[Math.floor(Math.random()*kinds.length)]; 
    const weapon=weapons[Math.floor(Math.random()*weapons.length)]; 
    const base = {x:W+60,y:groundY-48,w:40,h:48,kind,weapon,speed:4.1, kbx:0};

    if(kind==='flying'){ base.y=groundY-160; base.h=32; base.w=44; }

    // mob HP for floating bars (decreases during duel state)
    base.maxhp = (kind==='shielded'? 3 : 2);
    base.hp = base.maxhp;

    mobs.push(base);  
  }

  // Helpers
  function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

  function applyPlayerPhysics(){
    const left = keys.has('ArrowLeft')||keys.has('a'); const right = keys.has('ArrowRight')||keys.has('d'); const move=(right?1:0)-(left?1:0);
    player.vx = move*player.speed;

    if(state===State.DUEL){ 
      player.x = clamp(player.x + player.vx, duel.arenaX-60, duel.arenaX+60); 
    } else { 
      player.x = clamp(player.x + player.vx, 40, W*0.45); 
    }

    const wantJump = justPressed.has(' ')||justPressed.has('ArrowUp'); player.ducking = keys.has('ArrowDown');
    if(wantJump && player.onGround){ player.vy=-10.5; player.onGround=false; SFX.jump(); }
    player.vy += 0.45; 
    player.y += player.vy;

    // Apply and decay knockback
    if(Math.abs(player.kbx) > 0.01){
      player.x += player.kbx;
      player.kbx *= 0.88;
    }

    const standH=54, duckH=34; player.h = (player.ducking && state!==State.DUEL)? duckH : standH;
    if(player.y+player.h>=groundY){ player.y=groundY-player.h; player.vy=0; player.onGround=true; }

    if(player.attackTimer>0) player.attackTimer-=16.67; if(player.invuln>0) player.invuln-=16.67; if(player.parryFlash>0) player.parryFlash-=16.67;
  }

  function tryPlayerAttack(which){
    if(player.attackTimer>0) return; 
    player.attackType=which; player.attackTimer=200; SFX.attack();
    if(state===State.DUEL && duel){
      const reach=52; 
      const hitbox={ 
        x:player.x+player.w, 
        y:player.y + (which==='high'?0:(which==='mid'?player.h*0.33:player.h*0.66)) - 8, 
        w:reach, h:16 
      };
      let blocked=false; 
      if(duel.foe.kind==='shielded' && duel.shieldPos===which) blocked=true; 
      if(duel.foe.kind==='flying' && which!=='high') blocked=true;

      // Parry
      if(duel.activeStrike && duel.parryWindow>0){
        const zone = zoneFromY(duel.activeStrike.y);
        if(zone===which){ 
          duel.activeStrike=null; duel.parryWindow=0; 
          duel.foeHP=Math.max(0,duel.foeHP-1); 
          SFX.parry(); player.parryFlash=220; score+=75; 
          if(duel.foeHP<=0) endDuel(true); 
          return; 
        }
      }

      const foeBox = foeAABB();
      if(!blocked && aabb(hitbox, foeBox)){ duel.foeHP-=1; duel.hitFlash=120; if(duel.foeHP<=0) endDuel(true); }
    }
  }

  function beginDuel(foe){
    state=State.DUEL; hud.mode.textContent='Duel'; SFX.duel();

    // carry in mob HP/maxhp; default if missing
    const maxhp = foe.maxhp ?? (foe.kind==='shielded'?3:(foe.kind==='flying'?2:2));
    const hp = foe.hp ?? maxhp;

    duel={
      foe,
      arenaX: player.x+40, 
      timer:0, 
      foeHP: hp,
      foeMaxHP: maxhp,
      nextAttackAt:900, 
      pattern:nextZone(), 
      shieldPos:'mid', 
      shieldTimer:0, 
      projectiles:[], 
      hitFlash:0, 
      activeStrike:null, 
      parryWindow:0 
    };
  }

  function endDuel(playerWon){ 
    state=State.RUN; 
    hud.mode.textContent='Running'; 
    // (Optional) keep lane HP in sync if you reuse mobs after duel:
    // duel.foe.hp = duel.foeHP; 
    duel=null; 
    if(playerWon) score+=150; else score=Math.max(0,score-100); 
  }

  function foeAABB(){ 
    if(!duel) return {x:0,y:0,w:0,h:0}; 
    const f=duel.foe; 
    return { 
      x:duel.arenaX+50, 
      y:f.kind==='flying'? groundY-160: groundY-48, 
      w:f.kind==='flying'?44:40, 
      h:f.kind==='flying'?32:48 
    }; 
  }
  function nextZone(){ return ZONES[Math.floor(Math.random()*ZONES.length)]; }
  function zoneFromY(y){ return y < groundY-150 ? 'high' : (y < groundY-100 ? 'mid' : 'low'); }

  // ---- updateDuel(dt): COMPLETE (fix that broke Start) ----
  function updateDuel(dt){
    duel.timer+=dt;

    if(duel.foe.kind==='shielded'){ 
      duel.shieldTimer+=dt; 
      if(duel.shieldTimer>650){ 
        duel.shieldTimer=0; 
        const choices=ZONES.filter(z=>z!==duel.shieldPos); 
        duel.shieldPos=choices[Math.floor(Math.random()*choices.length)]; 
      } 
    }

    if(duel.foe.weapon==='bow'){
      if(!duel.nextArrowAt) duel.nextArrowAt=1200; 
      duel.nextArrowAt-=dt;
      if(duel.nextArrowAt<=0){ 
        duel.nextArrowAt=1300+Math.random()*700; 
        const zone=nextZone(); 
        const p={x:duel.arenaX+50, y:groundY-(zone==='high'?190: zone==='mid'?120:84), w:16, h:6, vx:-6.2, zone}; 
        duel.projectiles.push(p); 
      }
    }

    duel.nextAttackAt-=dt; 
    if(duel.nextAttackAt<=0){
      const zone=duel.pattern; 
      const s={ x:duel.arenaX+30, y:groundY-(zone==='high'?190: zone==='mid'?120:84), w:90, h:24, active:180 };
      duel.activeStrike=s; duel.parryWindow=200;
      duel.pattern=nextZone(); 
      const base=duel.foe.weapon==='spear'?1100:(duel.foe.weapon==='punch'?850:1000); 
      duel.nextAttackAt=base+Math.random()*500;
    }
    if(duel.parryWindow>0) duel.parryWindow-=dt;
    if(duel.activeStrike){ duel.activeStrike.active-=dt; if(duel.activeStrike.active<=0) duel.activeStrike=null; }

    // projectiles move + hit
    for(let i=duel.projectiles.length-1;i>=0;i--){ 
      const p=duel.projectiles[i]; 
      p.x+=p.vx; 
      const pb={x:p.x,y:p.y,w:p.w,h:p.h}; 
      if(aabb(pb,{x:player.x,y:player.y,w:player.w,h:player.h})){ 
        damagePlayer(); 
        duel.projectiles.splice(i,1); 
      } else if(p.x<player.x-120) { 
        duel.projectiles.splice(i,1); 
      }
    }

    // melee slab check
    if(duel.activeStrike){ 
      const s=duel.activeStrike; 
      const pb={x:player.x,y:player.y,w:player.w,h:player.h}; 
      if(aabb(pb,s)){ 
        const zone=zoneFromY(s.y); 
        const dodged=(zone==='high' && player.y+player.h < groundY-120) || 
                     (zone==='low' && (keys.has('ArrowDown')||player.h<40)) || 
                     (zone==='mid' && (player.y+player.h<groundY-90 || keys.has('ArrowDown'))); 
        if(!dodged) damagePlayer(); 
      } 
    }
  }

  function damagePlayer(){ 
    if(player.invuln>0) return; 
    player.hearts-=1; 
    player.invuln=900; 
    SFX.hurt(); 
    if(player.hearts<=0){ 
      state=State.GAMEOVER; hud.over.hidden=false; hud.final.textContent=`Score: ${Math.floor(score)}`; SFX.over(); 
    } 
  }

  // When the player bumps an obstacle during RUN: hurt + knockback
  function collidePlayerWithObstacle(o){
    if(state!==State.RUN) return;
    if(player.invuln<=0){ damagePlayer(); }
    player.kbx = -5.5;
    player.vy = Math.min(player.vy, -6);
    if(player.x + player.w > o.x && player.x < o.x) player.x = o.x - player.w - 1;
    SFX.hit();
  }

  // Mob/obstacle collision knockback (bounce)
  function collideMobWithObstacle(m,o){
    if(m.kind==='flying') return;
    if(m.x + m.w > o.x && m.x < o.x){
      m.x = o.x - m.w - 1; m.kbx = 5.5;
    } else if(m.x < o.x + o.w && m.x > o.x){
      m.x = o.x + o.w + 1; m.kbx = -5.0;
    }
  }

  function updateRun(dt){
    difficultyTime+=dt; const diff=Math.min(3.2, 1 + difficultyTime/20000);
    const runSpeed=5.2*diff; 
    scrollX+=runSpeed; score+=dt*0.06*diff;
    if(score>=nextWaveAt){ showBanner(`Wave ${++wave}`); nextWaveAt+=500+150*wave; }

    // FEWER OBSTACLES
    obstacleTimer-=dt; 
    if(obstacleTimer<=0){ 
      const base=1300/diff; 
      obstacleTimer=base + Math.random()*(1100/diff); 
      spawnObstacle(); 
    }

    spawnTimer-=dt; 
    if(spawnTimer<=0){ 
      const base=2000/diff; 
      spawnTimer=base + Math.random()*(1600/diff); 
      spawnMob(); 
    }

    // Move world
    obstacles.forEach(o=> o.x -= runSpeed); 
    for(let i=obstacles.length-1;i>=0;i--){ if(obstacles[i].x+obstacles[i].w<-20) obstacles.splice(i,1); }

    mobs.forEach(m=> { 
      m.x -= m.speed*diff*0.9; 
      if(Math.abs(m.kbx)>0.01){ m.x += m.kbx; m.kbx *= 0.88; }
    }); 
    for(let i=mobs.length-1;i>=0;i--){ if(mobs[i].x+mobs[i].w<-20) mobs.splice(i,1); }

    // Collisions: player vs obstacles
    for(const o of obstacles){ 
      if(aabb({x:player.x,y:player.y,w:player.w,h:player.h}, o)) { 
        collidePlayerWithObstacle(o); 
      } 
    }

    // Collisions: mobs vs obstacles
    for(const m of mobs){
      for(const o of obstacles){
        if(aabb({x:m.x,y:m.y,w:m.w,h:m.h}, o)){
          collideMobWithObstacle(m,o);
        }
      }
    }

    // Trigger duel when touching mob
    for(let i=0;i<mobs.length;i++){ 
      const m=mobs[i]; 
      const pb={x:player.x,y:player.y,w:player.w,h:player.h}; 
      if(aabb(pb,m)){ 
        const foe={...m}; 
        mobs.splice(i,1); 
        beginDuel(foe); 
        break; 
      } 
    }
  }

  // ==== RENDERING ===========================================================
  function drawGround(){ 
    ctx.fillStyle='#0b0c10'; ctx.fillRect(0,groundY,W,H-groundY); 
    ctx.strokeStyle='rgba(255,255,255,.06)'; 
    ctx.beginPath(); 
    for(let x=-((scrollX*0.5)%40); x<W; x+=40){ ctx.moveTo(x,groundY+2); ctx.lineTo(x+20,groundY+2); } 
    ctx.stroke(); 
  }
  function drawParallax(){ 
    ctx.fillStyle='rgba(255,255,255,.06)'; 
    const baseY=groundY-120; 
    for(let i=0;i<12;i++){ 
      const w=60+(i%3)*20; 
      const x=(i*180 - (scrollX*0.2)%180); 
      ctx.fillRect(x, baseY-(i%4)*20, w, 100+(i%3)*22); 
    } 
  }

  // --- sprites ---
  function drawPixelGrid(grid, palette, x, y, scale=2){
    for(let r=0;r<grid.length;r++){
      const row = grid[r];
      for(let c=0;c<row.length;c++){
        const ch=row[c];
        if(ch==='.' ) continue;
        ctx.fillStyle = palette[ch] || '#fff';
        ctx.fillRect(Math.floor(x+c*scale), Math.floor(y+r*scale), scale, scale);
      }
    }
  }

  const palKnight = { k:'#89a2ff', s:'#dfe6ff', b:'#2b2f3a', f:'#f7e4b2', h:'#454a5c', g:'#66e0a3' };
  const knightGrid = [
    "......g...........",
    "......g...........",
    "......g...........",
    "....kkkkk.........",
    "...kkfffkk........",
    "...kkfffkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkskskk........",
    "...kkbbbkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkkkkkk........",
    "...kkskskk........",
    "...kkskskk........",
    "...kkhhhkk........",
    "...kkhhhkk........",
    "...kkhhhkk........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........",
    "...k.....k........"
  ];

  const palGob = { G:'#76e06e', D:'#3a7a35', E:'#ffffff', e:'#111111', B:'#2b2f3a', M:'#9b6b3b' };
  const goblinGround = [
    "..BBBBBBBBBB..",
    ".BGGGGGGGGGGB.",
    "BGGGGEeEGGGGGB",
    "BGGGGGGGGGGGGB",
    "BGGGMGGGGMGGGB",
    "BGGGGGGGGGGGGB",
    "BGGGGGGGGGGGGB",
    "BGGGGGGGGGGGGB",
    ".BGGGGBBGGGGB.",
    "..BGB....BGB..",
    "..BGB....BGB..",
    "..BGB....BGB..",
    "..BGB....BGB..",
    "..BGB....BGB..",
    "...B......B...",
    "...B......B..."
  ];
  const goblinFlying = [
    "....BBBBBB....",
    "..BGGGGGGGB..W",
    ".BGGGEeEGGGB.W",
    "BGGGGGGGGGGGBW",
    "BGGGGGGGGGGGBW",
    ".BGGGGGGGGGB.W",
    "..BGGGGGGGB..W",
    ".WBGGGGGGGBW..",
    "W..BGGGGGB..W.",
    ".W..BBBB..W...",
    "..W.......W...",
    "...W.....W...."
  ];
  const palWing = { W:'#b29cff' };

  function drawKnight(x,y,w,h,attackType,attackTimer,ducking,parryFlash){
    const gw = knightGrid[0].length, gh = knightGrid.length;
    const scale = Math.floor(Math.min(w/gw, h/gh));
    const sx = x + Math.floor((w - gw*scale)/2);
    const sy = y + Math.floor(h - gh*scale);

    drawPixelGrid(knightGrid, palKnight, sx, sy, scale);

    if(parryFlash>0){
      const a = Math.min(0.35, parryFlash/220*0.35);
      ctx.fillStyle = `rgba(255,255,210,${a})`;
      ctx.fillRect(x-2, y-2, w+4, h+4);
    }

    // Sword aligned to zone
    const handYHigh = y + 6;
    const handYMid  = y + h*0.45;
    const handYLow  = y + h*0.75;
    const zoneY = attackType==='high' ? handYHigh : attackType==='mid' ? handYMid : handYLow;
    const t = attackTimer>0 ? 1 - attackTimer/200 : 0;
    const reach = 18 + Math.floor(18*t);
    const bladeW = Math.max(2, Math.floor(scale*0.9));

    ctx.fillStyle = '#cfd8ff';
    ctx.fillRect(x + w - 6, zoneY - 2, 4, 4);
    ctx.fillStyle = '#e6ecff';
    ctx.fillRect(x + w - 2, zoneY - Math.floor(bladeW/2), reach, bladeW);
  }

  function drawGoblin(m){
    const scale = 2;
    if(m.kind==='flying'){
      drawPixelGrid(goblinFlying, {...palGob, ...palWing}, m.x, (groundY-160), scale);
    }else{
      drawPixelGrid(goblinGround, palGob, m.x, (groundY-48), scale);
    }
    ctx.fillStyle='#111';
    ctx.font='12px system-ui';
    const glyphs={sword:'⚔',spear:'🗡',bow:'🏹',punch:'✊'};
    const y = m.kind==='flying'? (groundY-160) : (groundY-48);
    ctx.fillText(glyphs[m.weapon]||'?', m.x+6, y+14);

    if(m.kind==='shielded'){
      const w = m.kind==='flying'? 44 : 40;
      const h = m.kind==='flying'? 32 : 48;
      ctx.strokeStyle='#ddd';
      ctx.beginPath();
      ctx.arc(m.x + w/2, y + h/2, 12, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawObstacles(){ 
    ctx.fillStyle='#2b2f3a'; 
    obstacles.forEach(o=>{ 
      ctx.fillRect(o.x,o.y,o.w,o.h); 
      ctx.strokeStyle='rgba(255,255,255,.08)'; 
      ctx.strokeRect(o.x,o.y,o.w,o.h); 
    }); 
  }

  // HP BAR helper
  function drawHPBar(x, y, w, h, pct){
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(x, y, Math.max(0, Math.min(1, pct))*w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
  }

  function drawMob(m){ 
    ctx.save();
    const wob = m.kind==='flying'? Math.sin((scrollX+m.x)*0.05)*4 : 0;
    ctx.translate(0, wob);
    drawGoblin(m);

    // Floating HP bar above mob
    const y = m.kind==='flying'? (groundY-160) : (groundY-48);
    const barW = 36, barH = 4;
    const boxW = m.kind==='flying'? 44 : 40;
    const pct = (m.hp ?? m.maxhp) / (m.maxhp || 1);
    drawHPBar(m.x + (boxW - barW)/2, y - 10, barW, barH, pct);

    ctx.restore();
  }

  function drawDuel(){ 
    const foe=duel.foe; 
    const box=foeAABB(); 
    ctx.strokeStyle='rgba(255,255,255,.15)'; 
    ctx.strokeRect(duel.arenaX-70, groundY-100, 180, 120); 

    // Render goblin foe
    ctx.save();
    if(foe.kind==='flying'){
      const m = { ...foe, x: box.x, kind:'flying' };
      drawGoblin(m);
    } else if(foe.kind==='shielded'){
      const m = { ...foe, x: box.x, kind:'shielded' };
      drawGoblin(m);
    } else {
      const m = { ...foe, x: box.x, kind:'regular' };
      drawGoblin(m);
    }
    ctx.restore();

    // Foe HP bar in duel
    {
      const barW = 60, barH = 5;
      const barX = box.x + (box.w - barW)/2;
      const barY = box.y - 12;
      const pct = (duel.foeHP || 0) / (duel.foeMaxHP || 1);
      drawHPBar(barX, barY, barW, barH, pct);
    }

    // Shield marker
    if(foe.kind==='shielded'){
      const map={high: box.y-12, mid: box.y+8, low: box.y+24};
      ctx.fillStyle='#222';
      ctx.fillRect(box.x-10, map[duel.shieldPos], 10,10);
      ctx.strokeStyle='#ddd';
      ctx.strokeRect(box.x-10, map[duel.shieldPos], 10,10);
    }

    // Upcoming attack marker
    const zone=duel.pattern; 
    const zy= zone==='high'? box.y-30 : zone==='mid'? box.y-10 : box.y+10; 
    ctx.fillStyle='rgba(255,255,255,.2)'; 
    ctx.fillRect(box.x-6, zy, 4, 24); 

    // Active strike slab
    if(duel.activeStrike){ 
      ctx.fillStyle='rgba(255,80,80,.4)'; 
      const s=duel.activeStrike; 
      ctx.fillRect(s.x, s.y, s.w, s.h); 
    }

    // Projectiles
    ctx.fillStyle='#ffca3a'; 
    duel.projectiles.forEach(p=> ctx.fillRect(p.x,p.y,p.w,p.h)); 

    // On hit flash
    if(duel.hitFlash>0){ 
      duel.hitFlash-=16.67; 
      ctx.fillStyle='rgba(255,255,255,.1)'; 
      ctx.fillRect(box.x-4, box.y-4, box.w+8, box.h+8); 
    }
  }

  function drawUI(){ 
    hud.score.textContent=`Score: ${Math.floor(score)}`; 
    hud.hearts.textContent='❤︎'.repeat(Math.max(0,player.hearts)); 
    hud.mode.textContent = state===State.DUEL? 'Duel' : state===State.RUN? 'Running' : state===State.MENU? 'Menu' : 'Game Over'; 
  }

  function drawPlayer(){ 
    ctx.save(); 
    ctx.globalAlpha = player.invuln>0? 0.7:1; 
    drawKnight(player.x, player.y, player.w, player.h, player.attackType||'mid', player.attackTimer, player.ducking, player.parryFlash);
    ctx.restore(); 
  }

  // Hearts HUD
  function drawHeart(x, y, size, fill, stroke){
    const r = size/4;
    ctx.save();
    ctx.beginPath();
    ctx.arc(x - r, y - r, r, 0, Math.PI, true);
    ctx.arc(x + r, y - r, r, 0, Math.PI, true);
    ctx.lineTo(x, y + size*0.6);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    if(stroke){
      ctx.strokeStyle = stroke;
      ctx.lineWidth = Math.max(1, size*0.1);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawPlayerHearts(){
    const MAX = 3, size = 16, gap = 8, startX = 18, startY = 18;
    for(let i=0;i<MAX;i++){
      const cx = startX + i*(size + gap) + size/2;
      const cy = startY + size/2;
      const filled = i < player.hearts;
      drawHeart(cx, cy, size, filled ? '#ff6b6b' : 'rgba(255,255,255,0.15)', 'rgba(0,0,0,0.35)');
    }
  }

  // Loop
  let last=0; 
  function frame(t){ 
    const dt=Math.min(32, t-last || 16.67); 
    last=t; 
    ctx.clearRect(0,0,W,H); 
    drawParallax(); 
    if(state===State.RUN){ updateRun(dt); } 
    applyPlayerPhysics(); 
    drawGround(); 
    if(state===State.RUN){ drawObstacles(); mobs.forEach(drawMob);} 
    if(state===State.DUEL){ updateDuel(dt); drawDuel(); } 
    drawPlayer(); 

    drawPlayerHearts(); // canvas hearts HUD

    drawUI(); 
    justPressed.clear(); 
    requestAnimationFrame(frame); 
  }

  // Attack keys
  addEventListener('keydown', e=>{
    if(state===State.MENU && (e.key==='Enter'||e.key===' ')) resetGame();
    if(state===State.GAMEOVER && (e.key==='Enter'||e.key===' ')) resetGame();
    if(e.key==='j'||e.key==='J') tryPlayerAttack('high');
    if(e.key==='k'||e.key==='K') tryPlayerAttack('mid');
    if(e.key==='l'||e.key==='L') tryPlayerAttack('low');
  });

  // Touch buttons → keys
  (function(){ 
    const touch=document.getElementById('touch'); 
    const bindings={left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', jump:' ', atkH:'j', atkM:'k', atkL:'l'}; 
    function press(k){ keys.add(k); justPressed.add(k);} 
    function release(k){ keys.delete(k);} 
    function bind(el,key){ 
      ['touchstart','mousedown'].forEach(evt=> el.addEventListener(evt,e=>{ e.preventDefault(); press(key); }));
      ['touchend','touchcancel','mouseup','mouseleave'].forEach(evt=> el.addEventListener(evt,e=>{ e.preventDefault(); release(key); }));
    } 
    touch.querySelectorAll('.tbtn').forEach(btn=>{ 
      const act=btn.getAttribute('data-act'); 
      const key=bindings[act]; 
      if(key) bind(btn,key); 
    }); 
  })();

  // Swipe gestures (fixed typo: keys.delete)
  (function(){ 
    let sx=0, sy=0; 
    const TH=28; 
    canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true}); 
    canvas.addEventListener('touchend', e=>{ 
      const t=e.changedTouches[0]; 
      const dx=t.clientX-sx, dy=t.clientY-sy; 
      if(Math.abs(dx)<TH && Math.abs(dy)<TH) return; 
      if(Math.abs(dy)>Math.abs(dx)){ 
        if(dy<-TH){ justPressed.add(' '); } 
        else { keys.add('ArrowDown'); setTimeout(()=> keys.delete('ArrowDown'), 220); } 
      } else { 
        if(dx>TH){ keys.add('ArrowRight'); setTimeout(()=> keys.delete('ArrowRight'), 160); } 
        else if(dx<-TH){ keys.add('ArrowLeft'); setTimeout(()=> keys.delete('ArrowLeft'), 160); } 
      } 
    }, {passive:true}); 
  })();

  requestAnimationFrame(frame);
  </script>
</body>
</html>
